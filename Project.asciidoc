= Simulating the Energy Renewal of a Wireless Sensor Network with NS3

== Introduction

In this project we will describe the steps we took to simulate the
proposed ideas in the paper:


[quote, Liguang Xie & Yi Shi & Y. Thomas Hou & Hanif D. Sherali, http://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=06153401]
____

Making Sensor Networks Immortal: An Energy-Renewal Approach With
Wireless Power Transfer
____ 

The paper describes methods for recharging static sensors in an area
by a dedicated robot which will move in the area to recharge the
sensors. Its movement is dictated by the shortest hamiltonian path
which is gotten through reducing the problem to the _TSP_ which is
solved using linear programming.

The novelty of this paper is the optimization of the ratio of the
robot idle time over its traveling time -- keeping in mind that this
is more restrictive then the _TSP_ itself.

The main aim of this document is to simulate the scenario described by
the paper using NS3. In the next chapter we will describe the paper in
more detail to get the problem right. In chapter 3 and 4 we will
describe how the concepts of the paper can be mapped to NS3 and handle
the implementation. In chapter 5 we will handle the simulation
results, followed by the conclusion.

== Paper
=== Terminology
Node/Sensor:: 
    Used in the broad sense of Sensor-Networks, these nodes
    work on batteries.

WCV::
    The robot which can perform the energy transfer.

Sink:: 
    A special device which has no battery but can accept data
    transfers from nodes, this is the end-hop in the hop-by-hop
    network topology (the hop-by-hop is explained in the paper and
    later in this document).

=== Solving the problem

The problem of having 

.Formulas:

. dataflow
. energy-consumption/radio model
. arrival times
. complete cycle, including vacation time of WCV
. used energy should be charged in the same cycle, (per definition.)



== Mapping the concepts to NS3

=== Directly Mappable Models

==== Mobility model for the WCV (charging robot)

We'll have to device a new mobility model which actually does the
simulation of the proposed solution to the shortest hamiltonian
path. How the paper tries to solve this was explained in <<Paper>>

=== Nodes

Sensor Nodes correspond well to the generic notion of a node in NS3 


=== Battery / Charging Model

The nodes in the paper have a depletable battery, this can be
simulated by using NS3's energy framework:
http://www.nsnam.org/docs/release/3.10/manual/html/energy.html

=== Data Routing

Data routing will be according to the outcome of the algorithm in a
hop-to-hop fashion. 

=== Indirectly Mappable

=== Location

* location of the sensors which are needed for solving the relaxed TSP.
* ...?

[[implementation]]
== Implementation on NS3

=== Tools used

* NS3 
* Kdevelop (C++ IDE), installable easily through package managers like
  apt (debian(-derivates)) and even macports (OSX)

==== NS3

We shortly explain how we installed NS3, so this document provides
means to reproduce outcomes.

The following tutorial part was used:
http://www.nsnam.org/docs/release/3.18/tutorial/html/getting-started.html

More specifically, downloaded using `bake' and built using `waf' for
version 3.18

==== Kdevelop

Import the ns-3.18 directory. You'll notice not all sources are
recognized in the IDE when you'd open a NS3 source file, i.e. you
cannot ctrl-click on data structures and see it's definition. Add the
'ns-3.18/build' dir to the includes by clicking on a red underlined
header file (any will do). A new dialog will open in which you have a
textarea to fill in the 'ns-3.18/build' reference. (make this an
absolute path e.g. '/home/user/src/ns3/sourc/ns-3.18/build')

=== NS3 setup

We chose to make a NS3 module. By doing so we can benefit from the
infrastructure of NS3, e.g. testing during builds, example's source
code ends up in the correct directories -- ergo, our module will
behave predictable according to NS3 standards.

More info on how modules work:
http://www.nsnam.org/docs/manual/html/new-modules.html

In our setting you can symlink '/ns3/src/iot' from our work to
'$NS3_ROOT/src/iot'

[NOTE]
====
If you get errors about
----
Undefined symbols for architecture x86_64:
  "ns3::ErrorModel::GetTypeId()", referenced from:
      ns3::internal::APointerChecker<ns3::ErrorModel>
---- 
-- or other `Undefined symbols' Then make sure all dependencies of the
module are correct in 'ns3/src/iot/wscript' this appears to differ for
varying build platforms, e.g. on Ubuntu no dependencies were needed
whereas the same settings would complain as the above listing.
====

=== NS3 Concepts

For our implementation in NS3 we have models (and other NS3 concepts)
which depend on models, we choose to make a dependency graph of these
models and start implementing from the bottom up (i.e. implement
the components/models which do not depend on other models themselves.)

At this point we can assume we need the following high-level
models, please mind that we might need to review or refactor this
later.

* *MaxVacMobilityModel*- This mobility model will calculate the
   shortest path depending on the nodes in the area and solve the
   OPT-L algorithm being explained in the model. A feasible solution's
   results of the optimization OPT-L will be forwarded to the
   dependees
* *RechargingWaypointMobilityModel* - This model for the WCV will not
   simply stand still and move after a designated period, but it will
   start charging a waypoint which is also a location of a sensor
   node.
* *IotDevice*- Devices which can generate and forward sensor data
   towards a base/sink.
* *IotChannel* - represents the wireless communication channel from a source
  (sensor node) to a receiver(sensor node or sink)
* *RadioEnergyModelPhyListener* - Using the above layer2 models we'll
   have to listen to those devices' events and calculate energy
   correspondingly.

[graphviz]
----
digraph G { rankdir=UD; 
  Simulation
  ->MaxVacMobilityModel
  ->RechargingWaypointMobilityModel
  ->EnergyModel
  ->RadioEnergyModelPhyListener
  ->EnergyModel
    RadioEnergyModelPhyListener
  ->IotDevice
  ->IotChannel

  IotChannel
  ->IotDevice

  Simulation
  ->Nodes
  ->EnergyModel
}
----
=== Creating a new channel

In order to mimic the wireless communication lines in the paper, we
will implement a simple channel, which basically allows us to send
bits from one end, to the other of the channel. The channels
endpoints' are connected to a simple-device. Re-using the
+WifiModel+'s would most likely give us difficulties in the
energymodel. 

=== Creating a new HbH device

As said in the previous section, we cannot reuse the existing
+WifiModels+ therefore we must also implement a Device-model. 

==== Device behaviour 

We opted to use routing on layer 2, making it a form of shortcut-routing

=== Tapping into the energy framework

We'll take the control flow of the NS3's provided energy model of wifi as an example.

So in a trivial case, you'll have the following snippet:

[source,cc,numbered]
----
/* create some nodes */ 
NodeContainer c;
c.Create(5);
 
/* energy source */
BasicEnergySourceHelper basicSourceHelper;
// configure energy source
basicSourceHelper.Set ("BasicEnergySourceInitialEnergyJ", DoubleValue (0.1));
// install source
EnergySourceContainer sources = basicSourceHelper.Install (c);
/* device energy model */
WifiRadioEnergyModelHelper radioEnergyHelper;
// configure radio energy model
radioEnergyHelper.Set ("TxCurrentA", DoubleValue (0.0174));
// install device model
DeviceEnergyModelContainer deviceModels = radioEnergyHelper.Install (devices, sources);
----

We can see in the Install method that the Helper is making a
connection between NetDevices and EnergySources. The Helper creates
WifiRadioEnergyModels which describe a listener which is then attached
to the physical part of the WifiNetDeivce.

In the paper's scenario we have to create such a RadioEnergyModel,
which describes a listener for our simplified (non-wifi) wireless
physical layer -- which listens to actual bits send and not calculate
energy usage by time, the latter is the case of
WifiRadioEnergyModel. The paper however expresses energy use in terms
of bits send.

=== A waypoint mobility model with recharging at waypoints/nodes

Filler:

== Simulation results

Filler:

== Conclusion
